instanceof - 객체를 비교하는 연산자

<br/>

## 추상 클래스(abstract)

<br/>

```Java
public abstract class myHome{
}
```

<br/>

* - 미완성 클래스를 의미

<br/>

```Java
// myHome h = new myHome(); // 오류 발생
myHome h;
myHome[] h2 = new myHome[2]; // 오류 발생 안함
```
<br/>

추상 클래스로는 객체 할당이 불가능하다 -> 미완성 클래스이기 때문이다

그러나 myHome h; 와 같이 참고형으로는 사용이 가능하다.

이 경우 다형성을 이용해 자식 객체를 생성하여 받아올 수 있다.

<br/>

```Java
myHome[] h2 = new myHome[2];
```

<br/>

여기서 위 구문은 오류가 발생하지 않는데 잘 해석해본다면

위 구문은 myHome 자료형 배열인 h2를 생성하여 myHome 형의 배열 2개 만큼을 할당하겠다는 의미이다. 

**객체를 할당하는 것이 아닌 배열을 할당하는 것이다.**

<br/>



## 추상 메소드(abstarct)

* - 미완성 된 메소드. 내용 구현이 되어 있지 않음 {} 몸통부가 없음

* - 부모로부터 상속받은 추상 메소드를 구현하지 않는다면 추상 클래스로 지정해줘야 한다.
  * -> 상속받은 자식 클래스에서는 반드시 오버라이딩을 해줘야 한다.

<br/>

```java
public abstract void myRome();
```

<br/>

## 사용 이유?

<br/>

자손 클래스에서 추상 메서드를 반드시 사용하도록 강요하기 위해서이다.

 이는 상속보다 강력한 **'개념'** 이 된다.

<br/>

## 인터페이스

<br/>

이클립스 사용법 :  ctrl + n -> interface-

<br/>

 다중 상속 가능 -> 단일 상속에 대한 한계를 극복하였다.

인터페이스는 추상적인 개념이다.

어떤 객체가 특정한 인터페이스를 사용한다면 그 객체는 반드시 인터페이스 메소드를 구현해야 한다.

<br/>

```Java
/*public static filnal*/ int num = 10; 
```

<br/>

위의 코드에서 public static final을 주석 처리한 이유는 인터페이스에서의 필드는 반드시 '상수 필드'가 된다.

즉 위의 코드는 묵시적으로 선언되기 때문에 선언하지 않아도 컴파일러가 자동으로 가져가게 되는 것이다.

<br/>

```Java
/*public abstract*/ void room1();
```

<br/>

마찬가지로 인터페이스의 추상 메서드 또한 묵시적으로 선언되므로 위와 같이 생략이 가능하다.
